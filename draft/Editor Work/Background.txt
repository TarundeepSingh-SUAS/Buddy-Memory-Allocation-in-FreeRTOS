Background

|| Remark: Completed + Cited + No need to change ✅
|| Report + Conference Paper

The first personal computers were introduced in the 1970s. Since then memory has been one of the most determining factors in computing performance [11]. Early machines, like the Altair 8800, has few kilobytes of RAM. Thus programmers needed to write memory handling functions which were highly effective and optimized. Today, even though modern computers offer gigabytes of memory but domains like spacecraft control computers, deep-sea probes, IoT sensors, drones, and low-power microcontrollers (PineCone BL602) have to work within very strict memory limits. For example, NASA's Mars rovers execute sophisticated autonomous tasks with memories smaller than those in today's smart phones. Memory efficiency remains, therefore, at the core of engineering challenges.

So in embedded systems, this memory constraint is even more pronounced. Devices which we use on daily basis like refrigerator, washing machine, uses microcontrollers which often contain only a few hundred kilobytes of RAM, yet they must run real-time tasks (refrigerator has to maintain temperature) effectively. Nowadays, there is a trend of multiple device connected under one ecosystem and can be control remotely, dynamic memory usage increases, making efficient memory management a critical determinant of system reliability and longevity [12] (like in home, where a customer can control security system cameras, television, lighting by a single phone application).

Dynamic memory allocation provides the facility  to the running programs to request additional memory at run time. But this leads to two major problems: fragmentation (internal and external) and unpredictable times for doing tasks. The fragmentation occurs when free memory becomes fragmented into small, non-contiguous chunks that prevent allocators from satisfying larger requests. The paper "Dynamic Storage Allocation: A Survey and Critical Review", shows that fragmentation is among the major causes of performance degradation in long-running systems [5]. In order to operate reliably, embedded systems require allocation algorithms that are deterministic, fast, and resistant to fragmentation.


FreeRTOS is a popular real-time operating system for microcontrollers (like PineCone BL602), and has a number of heap management strategies available (heap_1 through to heap_5), each of which is optimized for different applications [6]. These implementations are based on either linear (heap_1 to heap_4) or region based (heap_5) allocation [6]. But none provide structured coalescing in order to mitigate fragmentation. In systems with high rates of allocation and deallocation, this can eventually lead to memory instability-an important issue in devices designed to operate for months or years without reboot.

The Buddy Memory Allocation Algorithm offers a solution to this challenge. First introduced by Knuth and later formalized by Peterson and Norman, the buddy system organizes memory into blocks whose sizes follow powers of two, enabling a structured process of splitting and merging memory on demand [1], [2]. When memory is freed, the allocator checks whether the adjacent “buddy” block is also free; if so, the two merge into a larger block. This predictable split-and-merge behavior leads to fast allocation, controlled fragmentation, and deterministic coalescing, making the buddy system especially suitable for real-time and embedded environments.

The Buddy Memory Allocation Algorithm offers a promising solution to this challenge. This idea was first introduced by Donald Knuth and later formalized and enhanced by Peterson and Norman, the buddy system organizes memory into blocks whose sizes follow powers of two pattern (must be in form of 2^n), thus allowing a structured process of splitting and merging memory on demand [1][2] (As shown in Diagram 1). During free operation, not only allocator makes memory available for use but also it checks whether the adjacent "buddy" block is also free. If the neighbour buddy (same size) is free, both merge into a larger block. And the allocator looks at this large block neighbour, if it is also free, it merges and the process goes on (as show in Diagram 2). This predictable split-and-merge behavior leads to fast allocation, controlled fragmentation, and deterministic coalescing, making the buddy system especially suitable for real-time and embedded environments.

Over the years, several enhancements—including the lazy buddy system [3], weighted buddy system [B], and improved constant-time buddy algorithms [4]—have refined its performance and reduced overhead, further solidifying its role in memory-constrained computing.

Over the years, refinements to its performance and reductions in overhead, such as the lazy buddy system [3], weighted buddy system [8], and enhanced constant-time buddy algorithms [4], have furthered make its popular for its implementation in memory-constrained computing. It has been implemented on general purpose computers and studied [9] but not for embedded systems like PineCone BL602 yet. Thus, this is the motivation for our project: "Buddy Memory Allocation in FreeRTOS".

The very limited memory of the BL602 RISC-V and the dynamic nature of FreeRTOS applications running atop make a buddy allocator a very serious alternative to default heap implementations. Buddy allocation integrated into  FreeRTOS enhances memory utilization, fragmentation reduction, and better performance as compared to standard heap implementation (heap_1 to heap_5, heap_bl602). This is shown further in this paper.


------------------------------------------------------------

\section{Background}
    \label{sec:background}

    The first personal computers were introduced in the 1970s. Since then memory has been one of the most determining factors in computing performance [11]. Early machines, like the Altair 8800, has few kilobytes of RAM. Thus programmers needed to write memory handling functions which were highly effective and optimized. Today, even though modern computers offer gigabytes of memory but domains like spacecraft control computers, deep-sea probes, IOT sensors, drones, and low-power micro-controllers (PineCone BL602) have to work within very strict memory limits. For example, NASA's Mars rovers execute sophisticated autonomous tasks with memories smaller than those in today's smart phones. Memory efficiency remains, therefore, at the core of engineering challenges.

    So in embedded systems, this memory constraint is even more pronounced. Devices which we use on daily basis like refrigerator, washing machine, uses micro-controllers which often contain only a few hundred kilobytes of RAM, yet they must run real-time tasks (refrigerator has to maintain temperature) effectively. Nowadays, there is a trend of multiple device connected under one ecosystem and can be control remotely, dynamic memory usage increases, making efficient memory management a critical determinant of system reliability and longevity [12] (like in home, where a customer can control security system cameras, television, lighting by a single phone application).

    Dynamic memory allocation provides the facility to the running programs to request additional memory at run time. But this leads to two major problems: fragmentation (internal and external) and unpredictable times for doing tasks. The fragmentation occurs when free memory becomes fragmented into small, non-contiguous chunks that prevent allocators from satisfying larger requests. The paper ``Dynamic Storage Allocation: A Survey and Critical Review'' shows that fragmentation is among the major causes of performance degradation in long-running systems [5]. In order to operate reliably, embedded systems require allocation algorithms that are deterministic, fast, and resistant to fragmentation.

    FreeRTOS is a popular real-time operating system for micro controllers (like PineCone BL602), and has a number of heap management strategies available (\texttt{heap\_1} through to \texttt{heap\_5}), each of which is optimized for different applications [6]. These implementations are based on either linear (\texttt{heap\_1} to \texttt{heap\_4}) or region based (\texttt{heap\_5}) allocation [6]. But none provide structured coalescing in order to mitigate fragmentation. In systems with high rates of allocation and de-allocation, this can eventually lead to memory instability---an important issue in devices designed to operate for months or years without reboot.

    The Buddy Memory Allocation Algorithm offers a solution to this challenge. First introduced by Knuth and later formalized by Peterson and Norman, the buddy system organizes memory into blocks whose sizes follow powers of two, enabling a structured process of splitting and merging memory on demand [1], [2]. When memory is freed, the allocator checks whether the adjacent ``buddy'' block is also free; if so, the two merge into a larger block. This predictable split-and-merge behavior leads to fast allocation, controlled fragmentation, and deterministic coalescing, making the buddy system especially suitable for real-time and embedded environments.

    The Buddy Memory Allocation Algorithm offers a promising solution to this challenge. This idea was first introduced by Donald Knuth and later formalized and enhanced by Peterson and Norman, the buddy system organizes memory into blocks whose sizes follow powers of two pattern (must be in form of $2^n$), thus allowing a structured process of splitting and merging memory on demand [1][2] (As shown in Diagram 1). During free operation, not only allocator makes memory available for use but also it checks whether the adjacent ``buddy'' block is also free. If the neighbor buddy (same size) is free, both merge into a larger block. And the allocator looks at this large block neighbor, if it is also free, it merges and the process goes on (as show in Diagram 2). This predictable split-and-merge behavior leads to fast allocation, controlled fragmentation, and deterministic coalescing, making the buddy system especially suitable for real-time and embedded environments.

    Over the years, several enhancements---including the lazy buddy system [3], weighted buddy system [B], and improved constant-time buddy algorithms [4]---have refined its performance and reduced overhead, further solidifying its role in memory-constrained computing.

    Over the years, refinements to its performance and reductions in overhead, such as the lazy buddy system [3], weighted buddy system [8], and enhanced constant-time buddy algorithms [4], have furthered make its popular for its implementation in memory-constrained computing. It has been implemented on general purpose computers and studied [9] but not for embedded systems like PineCone BL602 yet. Thus, this is the motivation for our project: ``Buddy Memory Allocation in FreeRTOS''.

    The very limited memory of the BL602 RISC-V and the dynamic nature of FreeRTOS applications running atop make a buddy allocator a very serious alternative to default heap implementations. Buddy allocation integrated into FreeRTOS enhances memory utilization, fragmentation reduction, and better performance as compared to standard heap implementation (\texttt{heap\_1} to \texttt{heap\_5}, \texttt{heap\_bl602}). This is shown further in this paper.